name: CD Prod Pipeline

concurrency:
  group: be-prod
  cancel-in-progress: true # CD 작업은 한번에 하나만 실행하도록 제한

on:
  push:
    tags:
      - 'v*.*.*-be'

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.get_version.outputs.VERSION }}

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpw
          MYSQL_DATABASE: testdb
        ports:
          - 3306:3306
        options: >-
          --health-cmd "mysqladmin ping -h localhost"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      SPRING_PROFILES_ACTIVE: prod
      SPRING_DATASOURCE_URL: jdbc:mysql://127.0.0.1:3306/testdb
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: testpw

      URL_ORIGIN_CLIENT: ${{ secrets.URL_ORIGIN_PROD }}

      DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 태그 검증을 위해 전체 Git 히스토리 필요

      - name: tag가 be/prod branch에 있는지 검증
        run: |
          git fetch origin be/prod
          if git merge-base --is-ancestor ${{ github.sha }} origin/be/prod; then
            echo "Tag is an ancestor of the be/prod branch. Proceeding with deployment."
          else
            echo "Error: This tag is not on the be/prod branch."
            exit 1
          fi

      - name: Git tag에서 버전 정보 추출
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> "$GITHUB_OUTPUT"

      - name: Setup JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: corretto
          java-version: 21

      - name: Gradle Wrapper 실행 권한 부여
        run: chmod +x ./gradlew

      - name: 전체 빌드
        run: ./gradlew clean build -x test --stacktrace -Dspring.profiles.active=prod

      - name: Docker Hub Login
        run: echo "${{ secrets.DOCKER_ACCESS_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & Push (multi-arch)
        uses: docker/build-push-action@v6
        with:
          context: ./
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ secrets.PROD_IMAGE_NAME }}:${{ steps.get_version.outputs.VERSION }}
            ${{ secrets.PROD_IMAGE_NAME }}:latest

  deploy:
    runs-on: [ self-hosted, estime-prod ]
    needs: build-and-push

    outputs:
      current: ${{ steps.detect.outputs.current }}
      target: ${{ steps.detect.outputs.target }}

    env:
      SPRING_PROFILES_ACTIVE: prod

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create env file for Docker Compose
        run: |
          cat <<EOF > .env
          IMAGE_NAME=${{ secrets.PROD_IMAGE_NAME }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.version }}
          EOF

      - name: Create env file for env.prod file
        working-directory: ./application
        run: |
          cat <<EOF > .env.prod
          ${{ secrets.ENV_PROD }}
          EOF

      - name: Prepare log directory
        run: |
          sudo mkdir -p /app/logs
          sudo chown -R 1001:1001 /app/logs

      - name: Detect current environment and determine target
        id: detect
        run: |
          set -e

          echo "=========================================="
          echo "Blue-Green 배포 환경 감지 시작"
          echo "=========================================="

          # Blue 환경 상태 확인
          BLUE_RUNNING=false
          if docker ps --format "{{.Names}}" | grep -q "^estime-api-blue$"; then
            echo "Blue 컨테이너 실행 중"
            if curl -sf http://localhost:8080/actuator/health > /dev/null 2>&1; then
              echo "Blue 헬스체크 통과"
              BLUE_RUNNING=true
            else
              echo "Blue 컨테이너는 있지만 헬스체크 실패"
            fi
          else
            echo "Blue 컨테이너 미실행"
          fi

          # Green 환경 상태 확인
          GREEN_RUNNING=false
          if docker ps --format "{{.Names}}" | grep -q "^estime-api-green$"; then
            echo "Green 컨테이너 실행 중"
            if curl -sf http://localhost:8081/actuator/health > /dev/null 2>&1; then
              echo "Green 헬스체크 통과"
              GREEN_RUNNING=true
            else
              echo "Green 컨테이너는 있지만 헬스체크 실패"
            fi
          else
            echo "Green 컨테이너 미실행"
          fi

          # 배포 전략 결정
          if [ "$BLUE_RUNNING" = true ] && [ "$GREEN_RUNNING" = false ]; then
            CURRENT="blue"
            TARGET="green"
            echo "현재 환경: Blue → 배포 대상: Green"
          elif [ "$GREEN_RUNNING" = true ] && [ "$BLUE_RUNNING" = false ]; then
            CURRENT="green"
            TARGET="blue"
            echo "현재 환경: Green → 배포 대상: Blue"
          elif [ "$BLUE_RUNNING" = false ] && [ "$GREEN_RUNNING" = false ]; then
            CURRENT="none"
            TARGET="blue"
            echo "현재 환경: 없음 → 초기 배포 대상: Blue"
          else
            CURRENT="both"
            TARGET="blue"
            echo "경고: Blue와 Green이 모두 실행 중입니다. Blue를 재배포합니다."
          fi

          echo "=========================================="
          echo "배포 결정: $CURRENT → $TARGET"
          echo "=========================================="

          echo "current=$CURRENT" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT

      - name: Pull new Docker image
        run: |
          echo "=========================================="
          echo "Docker 이미지 Pull 시작"
          echo "=========================================="
          docker compose -f docker-compose.prod.yml pull api-${{ steps.detect.outputs.target }}
          echo "이미지 Pull 완료"

      - name: Deploy target environment
        run: |
          TARGET="${{ steps.detect.outputs.target }}"
          echo "=========================================="
          echo "$TARGET 환경 배포 시작"
          echo "=========================================="

          # 기존 중지된 컨테이너가 있다면 제거
          if docker ps -a --format "{{.Names}}" | grep -q "^estime-api-$TARGET$"; then
            echo "기존 $TARGET 컨테이너 제거 중..."
            docker compose -f docker-compose.prod.yml rm -f api-$TARGET
          fi

          # 새 컨테이너 시작
          docker compose -f docker-compose.prod.yml up -d api-$TARGET
          echo "api-$TARGET 컨테이너 시작 완료"

      - name: Health check for new deployment
        run: |
          TARGET="${{ steps.detect.outputs.target }}"

          # 포트 설정 (blue=8080, green=8081)
          if [ "$TARGET" = "blue" ]; then
            PORT=8080
          else
            PORT=8081
          fi

          echo "=========================================="
          echo "$TARGET 환경 헬스체크 시작 (포트: $PORT)"
          echo "=========================================="

          echo "애플리케이션 초기화 대기 중... (10초)"
          sleep 10

          # 최대 12번 시도 (총 60초)
          for i in {1..12}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:$PORT/actuator/health || echo "000")

            if [ "$STATUS" -eq 200 ]; then
              echo "=========================================="
              echo "$TARGET 환경 배포 성공!"
              echo "=========================================="
              docker ps --filter "name=estime-api"
              exit 0
            fi

            echo "[$i/12] 헬스체크 재시도... (응답 코드: $STATUS)"
            sleep 5
          done

          # 헬스체크 실패 시
          echo "=========================================="
          echo "$TARGET 환경 헬스체크 실패"
          echo "=========================================="
          echo "컨테이너 상태:"
          docker ps -a --filter "name=estime-api"
          echo ""
          echo "컨테이너 로그:"
          docker logs estime-api-$TARGET --tail 100 || true

          exit 1

      - name: Switch Nginx traffic to new environment
        run: |
          TARGET="${{ steps.detect.outputs.target }}"
          CURRENT="${{ steps.detect.outputs.current }}"

          # 포트 매핑 (Blue: 8080, Green: 8081)
          if [ "$TARGET" = "blue" ]; then
            TARGET_PORT=8080
            OLD_PORT=8081
          else
            TARGET_PORT=8081
            OLD_PORT=8080
          fi

          echo "=========================================="
          echo "Nginx 트래픽 전환: $TARGET (포트 $TARGET_PORT)"
          echo "=========================================="

          echo "[1/4] 새 환경 헬스체크..."
          if ! curl -sf http://localhost:$TARGET_PORT/actuator/health > /dev/null; then
            echo "$TARGET 환경 응답 없음"
            exit 1
          fi
          echo "$TARGET 환경 정상"

          echo "[2/4] Nginx 포트 변경: $OLD_PORT → $TARGET_PORT"

          # 변경 전 현재 포트 확인
          CURRENT_PORT=$(grep -oP 'proxy_pass\s+http://127\.0\.0\.1:\K\d+' /etc/nginx/sites-available/default | head -1)
          echo "변경 전 포트: $CURRENT_PORT"

          # 현재 포트가 OLD_PORT인지 검증 (초기 배포 제외)
          if [ "$CURRENT" != "none" ] && [ "$CURRENT_PORT" != "$OLD_PORT" ]; then
            echo "포트 불일치: 예상 $OLD_PORT, 실제 $CURRENT_PORT"
            exit 1
          fi

          # 포트 변경
          sudo sed -i "s/\(proxy_pass\s\+http:\/\/127\.0\.0\.1:\)[0-9]\+/\1$TARGET_PORT/g" /etc/nginx/sites-available/default

          # 변경 후 포트 확인
          CHANGED_PORT=$(grep -oP 'proxy_pass\s+http://127\.0\.0\.1:\K\d+' /etc/nginx/sites-available/default | head -1)
          echo "변경 후 포트: $CHANGED_PORT"

          # 변경 후 포트가 TARGET_PORT인지 검증
          if [ "$CHANGED_PORT" != "$TARGET_PORT" ]; then
            echo "포트 불일치: 예상 $TARGET_PORT, 실제 $CHANGED_PORT"
            exit 1
          fi
          echo "포트 변경 완료"

          echo "[3/4] Nginx 리로드..."
          if ! sudo nginx -t 2>&1; then
            echo "Nginx 검증 실패"
            exit 1
          fi
          sudo systemctl reload nginx
          echo "Nginx 리로드 완료"

          echo "[4/4] Nginx 트래픽 전환 확인..."
          sleep 2
          if ! curl -sf https://prod.estime.today/actuator/health > /dev/null; then
            echo "헬스체크 실패"
            exit 1
          fi
          echo "전환 확인 완료"

          echo ""
          echo "=========================================="
          echo "Nginx 트래픽 전환 성공!"
          echo "   활성 환경: $TARGET (포트 $TARGET_PORT)"
          echo "=========================================="

      - name: Stop old environment
        if: success() && steps.detect.outputs.current != 'none' && steps.detect.outputs.current != 'both'
        run: |
          CURRENT="${{ steps.detect.outputs.current }}"
          TARGET="${{ steps.detect.outputs.target }}"

          echo "=========================================="
          echo "이전 환경 종료: $CURRENT"
          echo "=========================================="

          # 이전 환경 컨테이너 중지
          docker compose -f docker-compose.prod.yml stop api-$CURRENT

          echo "=========================================="
          echo "Blue-Green 배포 완료"
          echo "   이전 환경: $CURRENT (종료됨)"
          echo "   현재 환경: $TARGET (Nginx를 통해 서비스 중)"
          echo "=========================================="
          docker ps --filter "name=estime-api"

      - name: Clean up unused Docker resources
        if: always()
        run: |
          docker image prune -a -f
          docker builder prune -a -f

  rollback:
    runs-on: [ self-hosted, estime-prod ]
    needs: deploy
    if: failure() && needs.deploy.outputs.current != 'none'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Rollback to previous environment
        run: |
          CURRENT="${{ needs.deploy.outputs.current }}"
          TARGET="${{ needs.deploy.outputs.target }}"

          # 포트 매핑 (Blue: 8080, Green: 8081)
          if [ "$CURRENT" = "blue" ]; then
            ROLLBACK_PORT=8080
          else
            ROLLBACK_PORT=8081
          fi

          echo "=========================================="
          echo "배포 실패 감지 - 롤백 시작"
          echo "   이전 환경: $CURRENT (포트 $ROLLBACK_PORT)"
          echo "   실패한 환경: $TARGET"
          echo "=========================================="

          echo "[1/5] Nginx 설정을 이전 환경으로 복원 중..."
          sudo sed -i "s/\(proxy_pass\s\+http:\/\/127\.0\.0\.1:\)[0-9]\+/\1$ROLLBACK_PORT/g" /etc/nginx/sites-available/default

          # 복원 확인
          RESTORED_PORT=$(grep -oP 'proxy_pass\s+http://127\.0\.0\.1:\K\d+' /etc/nginx/sites-available/default | head -1)
          if [ "$RESTORED_PORT" != "$ROLLBACK_PORT" ]; then
            echo "Nginx 설정 복원 실패"
            exit 1
          fi
          echo "Nginx 설정 복원 완료 (포트: $RESTORED_PORT)"

          echo "[2/5] Nginx 리로드..."
          if ! sudo nginx -t 2>&1; then
            echo "Nginx 검증 실패"
            exit 1
          fi
          sudo systemctl reload nginx
          echo "Nginx 리로드 완료"

          echo "[3/5] 실패한 $TARGET 환경 정리 중..."
          docker compose -f docker-compose.prod.yml stop api-$TARGET || true
          docker compose -f docker-compose.prod.yml rm -f api-$TARGET || true
          echo "정리 완료"

          echo "[4/5] 이전 $CURRENT 환경 상태 확인..."
          if ! docker ps --format "{{.Names}}" | grep -q "^estime-api-$CURRENT$"; then
            echo "$CURRENT 환경이 중지됨. 재시작 중..."
            docker compose -f docker-compose.prod.yml up -d api-$CURRENT
            sleep 10
          fi

          echo "[5/5] 롤백 검증 중..."
          if ! curl -sf http://localhost:$ROLLBACK_PORT/actuator/health > /dev/null; then
            echo "롤백 검증 실패 - 수동 개입 필요"
            exit 1
          fi

          if ! curl -sf https://prod.estime.today/actuator/health > /dev/null; then
            echo "프로덕션 URL 검증 실패 - 수동 개입 필요"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "롤백 완료"
          echo "   복원된 환경: $CURRENT (포트 $ROLLBACK_PORT)"
          echo "   서비스가 정상적으로 복구되었습니다"
          echo "=========================================="
          docker ps --filter "name=estime-api"

      - name: Clean up unused Docker resources
        if: always()
        run: |
          docker image prune -a -f
          docker builder prune -a -f
